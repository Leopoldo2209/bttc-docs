"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9202],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>p});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=s(n),p=o,m=h["".concat(c,".").concat(p)]||h[p]||u[p]||r;return n?a.createElement(m,i(i({ref:t},d),{},{components:n})):a.createElement(m,i({ref:t},d))}));function p(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=h;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2196:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=n(7462),o=(n(7294),n(3905));const r={},i="State Transition",l={unversionedId:"bridge/state-transfer",id:"bridge/state-transfer",title:"State Transition",description:"BTTC validators are continuing to monitor the public blockchain's StateSender contract. When a contract registered on the public blockchain makes a call to StateSender, an event is generated. Validators on the BTTC network use this event to relay data to another contract on the BTTC network. This mechanism is known as state synchronization, and it is used to transfer data from the public blockchain to the BTTC blockchain.",source:"@site/docs/bridge/state-transfer.md",sourceDirName:"bridge",slug:"/bridge/state-transfer",permalink:"/docs/bridge/state-transfer",draft:!1,editUrl:"https://github.com/bttcprotocol/bttc-docs/tree/master/docs/bridge/state-transfer.md",tags:[],version:"current",lastUpdatedAt:1724138736,formattedLastUpdatedAt:"Aug 20, 2024",frontMatter:{}},c={},s=[{value:"Root Tunnel Contract",id:"root-tunnel-contract",level:2},{value:"Child Tunnel Contract",id:"child-tunnel-contract",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Transition of State Between Public Blockchain and BTTC",id:"transition-of-state-between-public-blockchain-and-bttc",level:2},{value:"BTTC state transfer to public blockchain",id:"bttc-state-transfer-to-public-blockchain",level:3}],d={toc:s};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"state-transition"},"State Transition"),(0,o.kt)("p",null,"BTTC validators are continuing to monitor the public blockchain's ",(0,o.kt)("inlineCode",{parentName:"p"},"StateSender")," contract. When a contract registered on the public blockchain makes a call to ",(0,o.kt)("inlineCode",{parentName:"p"},"StateSender,")," an event is generated. Validators on the BTTC network use this event to relay data to another contract on the BTTC network. This mechanism is known as state synchronization, and it is used to transfer data from the public blockchain to the BTTC blockchain."),(0,o.kt)("p",null,"BTTC validators submit the hash values of all BTTC transactions to the public blockchain on a regular basis. This submission is referred to as a checkpoint, and it can be used to verify any BTTC transaction. When the verification is successful, the corresponding actions on the public blockchain can be taken."),(0,o.kt)("p",null,"Both mechanisms are used concurrently to enable bidirectional data transfer between BTTC and the public blockchain. To abstract these interactions, you can directly inherit our public blockchain contract ",(0,o.kt)("inlineCode",{parentName:"p"},"FxBaseRootTunnel")," and the BTTC contract ",(0,o.kt)("inlineCode",{parentName:"p"},"FxBaseChildTunnel"),"."),(0,o.kt)("h2",{id:"root-tunnel-contract"},"Root Tunnel Contract"),(0,o.kt)("p",null,"The following functions are available via the ",(0,o.kt)("inlineCode",{parentName:"p"},"FxBaseRootTunnel")," contract:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_processMessageFromChild(bytes memory data)"),": This function is used to process data received from Child Tunnel."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_sendMessageToChild(bytes memory message)"),": Pass any byte data as a parameter and call this function within the contract; the data will be sent to Child Tunnel in its entirety."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"receiveMessage(bytes memory inputData)"),": this function is used to receive messages sent by Child Tunnel. ",(0,o.kt)("inlineCode",{parentName:"li"},"calldata")," must be used to provide proof of transaction.")),(0,o.kt)("h2",{id:"child-tunnel-contract"},"Child Tunnel Contract"),(0,o.kt)("p",null,"The following functions are available via the FxBaseChildTunnel contract:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_processMessageFromRoot(uint256 stateId, sender address, bytes memory data)"),": this function is used to process data sent via the Root Tunnel."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_sendMessageToRoot(bytes memory message)"),": Use this function to send any byte data to the Root Tunnel from within the contract.")),(0,o.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"On the public blockchain, the Root contract must inherit the ",(0,o.kt)("inlineCode",{parentName:"li"},"FxBaseRootTunnel")," contract. Similarly, the sub-contracts on BTTC must inherit the ",(0,o.kt)("inlineCode",{parentName:"li"},"FxBaseChildTunnel")," contract."),(0,o.kt)("li",{parentName:"ol"},"The location of the ",(0,o.kt)("inlineCode",{parentName:"li"},"_checkpointManager")," object"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"_fxChild")," has the address ",(0,o.kt)("inlineCode",{parentName:"li"},"_fxChild")),(0,o.kt)("li",{parentName:"ol"},"Call the",(0,o.kt)("inlineCode",{parentName:"li"},"setChildTunnel")," method on the root tunnel using the address of the child tunnel; concurrently, call the",(0,o.kt)("inlineCode",{parentName:"li"},"setRootTunnel")," method on the child tunnel using the address of the root tunnel.")),(0,o.kt)("h2",{id:"transition-of-state-between-public-blockchain-and-bttc"},"Transition of State Between Public Blockchain and BTTC"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Within the root contract, call ",(0,o.kt)("inlineCode",{parentName:"li"},"_sendMessageToChild()")," to send data to BTTC."),(0,o.kt)("li",{parentName:"ul"},"In the sub-contract, implement ",(0,o.kt)("inlineCode",{parentName:"li"},"_processMessageFromRoot()")," to retrieve data from the public blockchain. When the status is synchronized, the data from the status receiver is automatically received.")),(0,o.kt)("h3",{id:"bttc-state-transfer-to-public-blockchain"},"BTTC state transfer to public blockchain"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Call ",(0,o.kt)("inlineCode",{parentName:"li"},"_sendMessageToRoot()")," in the sub-contract to send the data to the public blockchain."),(0,o.kt)("li",{parentName:"ul"},"After the transaction hash is collected in the checkpoint, it will be used to generate a proof. The following code can be used to generate a proof using the hash of the transaction.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const bttcPOSClient = new require("@bttcnetwork/bttcjs").BttcPOSClient({\n  network: "",\n  version: "",\n  maticProvider: "https://rpc-mumbai.matic.today", // when using mainnet, replace to bttc mainnet RPC endpoint\n  parentProvider: "https://rpc.slock.it/goerli", // when using mainnet, replace to ethereum mainnet RPC endpoint\n});\nconst proof = bttcPOSClient.posRootChainManager\n  .customPayload(\n    "0x3cc9f7e675bb4f6af87ee99947bf24c38cbffa0b933d8c981644a2f2b550e66a", // replace with txn hash of sendMessageToRoot\n    "0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036" // SEND_MESSAGE_EVENT_SIG, do not change\n  )\n  .then(console.log);\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"In the root contract, implement ",(0,o.kt)("inlineCode",{parentName:"li"},"_processMessageFromChild()"),"."),(0,o.kt)("li",{parentName:"ul"},"To retrieve data sent from the child tunnel, pass the generated certificate as a parameter to",(0,o.kt)("inlineCode",{parentName:"li"},"receiveMessage()"),".")))}u.isMDXComponent=!0}}]);