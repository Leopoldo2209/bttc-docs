"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3750],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),h=l(n),m=o,u=h["".concat(s,".").concat(m)]||h[m]||d[m]||a;return n?r.createElement(u,i(i({ref:t},p),{},{components:n})):r.createElement(u,i({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=h;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},4883:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var r=n(7462),o=(n(7294),n(3905));const a={},i="Checkpoint Mechanism",c={unversionedId:"validator/core-components/checkpoint",id:"validator/core-components/checkpoint",title:"Checkpoint Mechanism",description:"BTTC depends on the TRON Mainnet as its Layer 1 Settlement Layer.",source:"@site/docs/validator/core-components/checkpoint.md",sourceDirName:"validator/core-components",slug:"/validator/core-components/checkpoint",permalink:"/docs/validator/core-components/checkpoint",draft:!1,editUrl:"https://github.com/bttcprotocol/bttc-docs/tree/master/docs/validator/core-components/checkpoint.md",tags:[],version:"current",lastUpdatedAt:1724138736,formattedLastUpdatedAt:"Aug 20, 2024",frontMatter:{},sidebar:"validatorSidebar",previous:{title:"Bttc Layer",permalink:"/docs/validator/core-components/bttc-layer"},next:{title:"Key Management",permalink:"/docs/validator/core-components/key-management"}},s={},l=[],p={toc:l};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"checkpoint-mechanism"},"Checkpoint Mechanism"),(0,o.kt)("admonition",{title:"BTTC is not a Layer 1 platform",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"BTTC depends on the TRON Mainnet as its Layer 1 Settlement Layer.\nAll staking mechanics need to be in sync with the contracts on the TRON mainnet.")),(0,o.kt)("p",null,"Proposers for a checkpoint are initially selected via Tendermint\u2019s weighted ",(0,o.kt)("a",{parentName:"p",href:"https://docs.tendermint.com/master/spec/consensus/proposer-selection.html"},"round-robin algorithm"),". A further custom check is implemented based on the checkpoint submission success. This allows the BTTC system to decouple with Tendermint proposer selection and provides BTTC with the abilities like selecting a proposer only when the checkpoint transaction on the TRON mainnet succeeds or submitting a checkpoint transaction for the blocks belonging to previous failed checkpoints."),(0,o.kt)("p",null,"Successfully submitting a checkpoint on Tendermint is a 2-phase commit process:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A proposer, selected via the round-robin algorithm, sends a checkpoint with the proposer's address and the Merkle hash in the proposer field."),(0,o.kt)("li",{parentName:"ul"},"All other proposers validate the data in the proposer field before adding the Merkle hash in their state.")),(0,o.kt)("p",null,"The next proposer then sends an acknowledgment transaction to prove that the previous checkpoint transaction has succeeded on the TRON mainnet. Every validator set change is relayed by the validator nodes on Delivery which is embedded onto the validator node. This allows Delivery to remain in sync with the BTTC contract state on the TRON mainnet at all times."),(0,o.kt)("p",null,"The BTTC contract deployed on the TRON/BSC/Ethereum  mainnet is considered to be the ultimate source of truth, and therefore all validation is done via querying the TRON/BSC/Ethereum mainnet contract."))}d.isMDXComponent=!0}}]);