"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1331],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),h=o,m=u["".concat(c,".").concat(h)]||u[h]||p[h]||a;return n?r.createElement(m,i(i({ref:t},d),{},{components:n})):r.createElement(m,i({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8712:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=n(7462),o=(n(7294),n(3905));const a={},i="Token Deposit & Withdraw",s={unversionedId:"bridge/deposit-and-withdraw",id:"bridge/deposit-and-withdraw",title:"Token Deposit & Withdraw",description:"Using ERC-20 as an example, the process for topping up is:",source:"@site/docs/bridge/deposit-and-withdraw.md",sourceDirName:"bridge",slug:"/bridge/deposit-and-withdraw",permalink:"/docs/bridge/deposit-and-withdraw",draft:!1,editUrl:"https://github.com/bttcprotocol/bttc-docs/tree/master/docs/bridge/deposit-and-withdraw.md",tags:[],version:"current",lastUpdatedAt:1724138736,formattedLastUpdatedAt:"Aug 20, 2024",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Assets Mapping",permalink:"/docs/bridge/assets-mapping"},next:{title:"Relayer",permalink:"/docs/category/relayer"}},c={},l=[{value:"Detailed Process",id:"detailed-process",level:2},{value:"Instantiated Contracts",id:"instantiated-contracts",level:3},{value:"Approve",id:"approve",level:3},{value:"Deposit",id:"deposit",level:3},{value:"Burn/Destroy",id:"burndestroy",level:3},{value:"Exit",id:"exit",level:3}],d={toc:l};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"token-deposit--withdraw"},"Token Deposit & Withdraw"),(0,o.kt)("p",null,"Using ERC-20 as an example, the process for topping up is:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Approve the ERC20Predicate contract, allowing it to control the tokens that need to be deposited."),(0,o.kt)("li",{parentName:"ol"},"invoke depositFor on the RootChainManager.")),(0,o.kt)("p",null,"The withdrawal process is:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Destroy the token on the BTTC. 2."),(0,o.kt)("li",{parentName:"ol"},"call the exit method on the RootChainManager to submit proof of destruction. This needs to be called after the checkpoint containing the destroyed transaction has been submitted.")),(0,o.kt)("h2",{id:"detailed-process"},"Detailed Process"),(0,o.kt)("h3",{id:"instantiated-contracts"},"Instantiated Contracts"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const mainWeb3 = new Web3(mainProvider)\nconst bttcWeb3 = new Web3(bttcProvider)\nconst rootTokenContract = new mainWeb3.eth.Contract(rootTokenABI, rootTokenAddress)\nconst rootChainManagerContract = new mainWeb3.eth.Contract(rootChainManagerABI, rootChainManagerAddress)\nconst childTokenContract = new bttcWeb3(childTokenABI, childTokenAddress)\n")),(0,o.kt)("h3",{id:"approve"},"Approve"),(0,o.kt)("p",null,"Approve the contract ERC20Predicate consumption tokens. Approve requires two parameters: address and amount."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"await rootTokenContract.methods\n  .approve(erc20Predicate, amount)\n  .send({ from: userAddress })\n")),(0,o.kt)("h3",{id:"deposit"},"Deposit"),(0,o.kt)("p",null,"Invoke the depositFor method of the RootChainManager contract. This method takes three parameters: the address of the user receiving the deposit on BTTC, the address of the token contract on the root chain and the amount (in the form of an ABI code)."),(0,o.kt)("p",null,"Please ensure that the correct approve operation has been carried out before making the deposit."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const depositData = mainWeb3.eth.abi.encodeParameter('uint256', amount)\nawait rootChainManagerContract.methods\n  .depositFor(userAddress, rootToken, depositData)\n  .send({ from: userAddress })\n")),(0,o.kt)("h3",{id:"burndestroy"},"Burn/Destroy"),(0,o.kt)("p",null,"Call the withdraw method of the child token contract to destroy the tokens on BTTC. This method accepts a single parameter: the quantity of tokens to destroy. The proof of token destruction must be submitted in the subsequent operation, which means that the hash of the token destruction transaction must be stored."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const burnTx = await childTokenContract.methods\n  .withdraw(amount)\n  .send({ from: userAddress })\nconst burnTxHash = burnTx.transactionHash\n")),(0,o.kt)("h3",{id:"exit"},"Exit"),(0,o.kt)("p",null,"To unlock and receive tokens from the ERC20Predicate contract, invoke the RootChainManager contract's exit method. This method accepts a single parameter: the proof of the token's destruction."),(0,o.kt)("p",null,"Prior to calling this method, you must ensure that the checkpoint containing the destroyed transaction was successfully submitted. The destruction certificate uses RLP encoding rules to generate the following fields:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"headerNumber: The checkpoint starting block containing the destruction transaction"),(0,o.kt)("li",{parentName:"ul"},"blockProof: Ensure that the block header is the proof of the leaf in the tree where the submitted Merkel root is located"),(0,o.kt)("li",{parentName:"ul"},"blockNumber: contains the block number of the destruction transaction"),(0,o.kt)("li",{parentName:"ul"},"blockTime: contains the block time of the destroyed transaction"),(0,o.kt)("li",{parentName:"ul"},"txRoot: the transaction root of the block"),(0,o.kt)("li",{parentName:"ul"},"receiptRoot: the receipt root of the block"),(0,o.kt)("li",{parentName:"ul"},"receipt: the receipt of the destroyed transaction"),(0,o.kt)("li",{parentName:"ul"},"receiptProof: Merkel root that destroys the transaction receipt"),(0,o.kt)("li",{parentName:"ul"},"branchMask: a 32-bit parameter indicating the position of receipt in the Merkle Patricia Tree"),(0,o.kt)("li",{parentName:"ul"},"receiptLogIndex: log index used to read from receipt")),(0,o.kt)("p",null,"Because manually generating the certificate is inconvenient, we recommend using the BTTC SDK. If you wish to manually send the transaction, set encodeAbi to true to obtain the original call data."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const exitCalldata = await bttcPOSClient\n  .exitERC20(burnTxHash, { from, encodeAbi: true })\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"await mainWeb3.eth.sendTransaction({\n  from: userAddress,\n  to: rootChainManagerAddress,\n  data: exitCalldata.data\n})\n")))}p.isMDXComponent=!0}}]);