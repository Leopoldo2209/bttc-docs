"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4319],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>h});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=n.createContext({}),s=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(r),h=o,m=u["".concat(c,".").concat(h)]||u[h]||d[h]||a;return r?n.createElement(m,i(i({ref:t},p),{},{components:r})):n.createElement(m,i({ref:t},p))}));function h(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<a;s++)i[s]=r[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},9728:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>s});var n=r(7462),o=(r(7294),r(3905));const a={},i="Delivery Layer",l={unversionedId:"validator/core-components/delivery-layer",id:"validator/core-components/delivery-layer",title:"Delivery Layer",description:"Delivery is is the proof-of-stake verifier layer, which is responsible for checkpointing the representation of the Bttc layer blocks to the TRON/BSC/Ethereum mainnet. Delivery is based on Tendermint.",source:"@site/docs/validator/core-components/delivery-layer.md",sourceDirName:"validator/core-components",slug:"/validator/core-components/delivery-layer",permalink:"/docs/validator/core-components/delivery-layer",draft:!1,editUrl:"https://github.com/bttcprotocol/bttc-docs/tree/master/docs/validator/core-components/delivery-layer.md",tags:[],version:"current",lastUpdatedAt:1724138736,formattedLastUpdatedAt:"Aug 20, 2024",frontMatter:{},sidebar:"validatorSidebar",previous:{title:"Reward",permalink:"/docs/validator/rewards"},next:{title:"Bttc Layer",permalink:"/docs/validator/core-components/bttc-layer"}},c={},s=[],p={toc:s};function d(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"delivery-layer"},"Delivery Layer"),(0,o.kt)("p",null,"Delivery is is the proof-of-stake verifier layer, which is responsible for checkpointing the representation of the Bttc layer blocks to the TRON/BSC/Ethereum mainnet. Delivery is based on ",(0,o.kt)("a",{parentName:"p",href:"https://tendermint.com/"},"Tendermint"),"."),(0,o.kt)("p",null,"The staking contract on the TRON mainnet works in conjunction with the Delivery node to act as the trustless stake management mechanism for the PoS engine, including selecting the validator set, updating validators, etc. Since staking is done in the contract on the TRON mainnet, BTTC does not rely only on validator honesty and instead inherits the TRON  mainnet security."),(0,o.kt)("p",null,"Delivery layer handles the aggregation of blocks produced by Bttc into a Merkle tree and publishes the Merkle root periodically to the TRON/BSC/Ethereum mainnet. This periodic publishing is called ",(0,o.kt)("em",{parentName:"p"},"checkpointing"),"."),(0,o.kt)("p",null,"For every few blocks on Bttc, a validator (on the Delivery layer):"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Validates all the blocks since the last checkpoint."),(0,o.kt)("li",{parentName:"ol"},"Creates a Merkle tree of the block hashes."),(0,o.kt)("li",{parentName:"ol"},"Publishes the Merkle root to the TRON/BSC/Ethereum mainnet.")),(0,o.kt)("p",null,"Checkpoints are important for two reasons:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Providing finality on the root chain."),(0,o.kt)("li",{parentName:"ol"},"Providing proof of burn in withdrawal of assets.")),(0,o.kt)("p",null,"An overview of the process:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A subset of active validators from the pool are selected to act as block producers for a span. The Selection of each span will also be consented by at least 2/3 in power. These block producers are responsible for creating blocks and broadcasting it to the remaining of the network."),(0,o.kt)("li",{parentName:"ul"},"A checkpoint includes the root of all blocks created during any given interval. All nodes validate the same and attach their signature to it."),(0,o.kt)("li",{parentName:"ul"},"A selected proposer from the validator set is responsible for collecting all signatures for a particular checkpoint and committing the same on the main-chain."),(0,o.kt)("li",{parentName:"ul"},"The responsibility of creating blocks and also proposing checkpoints is variably dependent on a validator\u2019s stake ratio in the overall pool.")))}d.isMDXComponent=!0}}]);